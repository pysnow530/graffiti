# Canvas 涂鸦板

一个基于HTML5 Canvas的简单涂鸦应用，支持自由绘画和基本的画笔控制功能。

## 功能特性

- 🎨 **自由绘画** - 使用鼠标或触摸屏进行绘画
- 🌈 **颜色选择** - 支持任意颜色选择
- 📏 **画笔大小** - 可调节画笔粗细（1-50px）
- 📷 **图片导入** - 支持导入本地图片进行编辑和涂鸦
- 🔍 **图像描边** - 多角度全覆盖边缘检测，用蓝点标记图像轮廓
- ⚙️ **扫描精度** - 可调节角度扫描间隔（1-20度）
- 🕸️ **智能网格** - 自动生成6等分网格，垂直连接+水平等分线
- 🔧 **网格定制** - 自定义网格颜色、线宽、容差等参数
- 🐠 **厚度轮廓** - 基于鱼形算法的厚度函数，支持多种形状和可视化方式
- 🎨 **多种厚度函数** - 鱼形、椭圆形、纺锤形、叶子形等多种厚度分布
- 🧹 **清空画布** - 一键清空所有内容
- 💾 **保存图片** - 将作品保存为PNG格式
- 📱 **移动端支持** - 支持触摸设备使用
- 🎯 **响应式设计** - 适配不同屏幕尺寸

## 如何使用

1. **开始绘画**
   - 在画布上按住鼠标左键并拖动即可开始绘画
   - 移动设备上可以用手指触摸绘画

2. **调整画笔**
   - 点击颜色选择器更换画笔颜色
   - 拖动滑块调整画笔大小

3. **导入图片**
   - 点击"导入图片"按钮选择本地图片文件
   - 支持常见图片格式（JPG、PNG、GIF等）
   - 图片会自动适应画布尺寸，保持原始比例
   - 导入后可以在图片上进行涂鸦和描边

4. **图像描边**
   - 调整"扫描精度"滑块设置角度间隔（数值越小，扫描越密集）
   - 点击"图像描边"按钮对当前画布内容进行多角度全覆盖边缘检测
   - 系统使用宽度为5个点的扫描带代替单线扫描，提供高效的边缘检测鲁棒性
   - 用蓝色圆点标记出图像的外轮廓边缘
   - **智能网格生成**：自动将轮廓切分成两条线，生成垂直连接并进行6等分
   - **网格效果**：统一绿色的垂直线和水平等分线，形成精细的网格结构
   - **厚度轮廓**：基于鱼形算法为轮廓添加厚度，支持多种形状和可视化方式

5. **厚度轮廓功能**
   - **鱼形厚度**：头部尖锐、身体厚实、尾部细小的自然形状
   - **椭圆形厚度**：中间厚、两端细的对称形状
   - **纺锤形厚度**：平滑过渡的梭形效果
   - **叶子形厚度**：一端尖锐、一端圆润的不对称形状
   - **可视化方式**：线条模式、圆形模式、渐变填充模式

6. **管理作品**
   - 点击"清空画布"按钮清除所有内容
   - 点击"保存图片"按钮下载PNG格式的作品

## 项目结构

```
graffiti/
├── index.html              # 主页面
├── style.css               # 样式文件
├── js/                     # JavaScript模块目录
│   ├── utils.js            # 通用工具函数
│   ├── drawing-engine.js   # 画布绘图引擎
│   ├── image-processor.js  # 图像处理器
│   ├── edge-detection.js   # 边缘检测算法
│   └── graffiti-app.js     # 主应用控制器
├── script.js.backup        # 原始单文件备份
└── README.md               # 说明文档
```

## 模块化架构

### 🎨 DrawingEngine (绘图引擎)
- **职责**: 画笔绘制、画布初始化和基本操作
- **功能**: 
  - 画笔绘制 (startDrawing, draw, stopDrawing)
  - 画布操作 (initCanvas, clearCanvas, saveCanvas)
  - 鼠标/触摸事件处理
  - 画笔设置 (颜色、大小)

### 📷 ImageProcessor (图像处理器)
- **职责**: 图片导入、处理和在画布上绘制
- **功能**:
  - 图片上传和验证
  - 图片缩放和绘制到画布
  - 像素数据获取和分析
  - **智能轮廓绘制**（点+连线）
  - **路径排序算法**（最近邻）
  - **道格拉斯-普克压缩算法**
  - **轮廓切分算法**（最右侧点切分）
  - **6等分网格生成**（垂直连接+水平等分线）
  - **厚度轮廓算法**（鱼形函数+多种可视化）

### 🔍 EdgeDetectionAlgorithm (边缘检测算法)
- **职责**: 图像边缘检测和相关算法实现
- **功能**:
  - 多角度全覆盖扫描算法
  - 圆形区域像素检测
  - 性能统计和监控
  - 边缘点提取和优化
- **数据格式**: 返回结构化点对象数组 `[{x: number, y: number}, ...]`

### 🎛️ GraffitiApp (主应用控制器)
- **职责**: 整体协调、UI交互和通知系统
- **功能**:
  - 模块间协调和通信
  - UI事件绑定和处理
  - 通知系统管理
  - 应用生命周期管理
  - **边缘检测结果绘制协调**

### 🛠️ Utils (工具函数)
- **职责**: 通用辅助功能
- **功能**:
  - 数学计算函数
  - 格式化工具
  - 防抖节流函数
  - 深拷贝等通用方法

## 技术实现

- **HTML5 Canvas** - 绘图功能的核心
- **JavaScript ES6+** - 模块化类组织，职责分离
- **File API & FileReader** - 本地图片文件读取和处理
- **Image对象处理** - 图片缩放、适配和绘制
- **多角度边缘检测算法** - 基于5点宽扫描带的轻量级鲁棒性描边功能
- **Canvas ImageData API** - 像素级图像数据处理
- **CSS3** - 现代化的界面设计和通知系统
- **响应式布局** - 适配多种设备
- **结构化数据** - 边缘检测返回标准化的点对象数组
- **最近邻路径排序算法** - 将散乱的边缘点组织成连续路径
- **道格拉斯-普克压缩算法** - 智能简化路径，保持形状特征
- **轮廓切分算法** - 基于最右侧点的智能切分，将轮廓分成两条线
- **6等分网格算法** - 垂直连接点匹配+线性插值+水平等分线绘制
- **厚度轮廓算法** - 基于鱼形函数的厚度分布计算+多种可视化方式
- **数学厚度函数** - 鱼形、椭圆形、纺锤形、叶子形等多种厚度分布函数

## 运行方法

1. 直接在浏览器中打开 `index.html` 文件即可使用
2. 或者使用本地服务器：
   ```bash
   # 使用Python简单服务器
   python -m http.server 8000
   
   # 使用Node.js服务器
   npx serve .
   ```

## 浏览器兼容性

- Chrome 60+
- Firefox 55+
- Safari 12+
- Edge 79+

## 开发说明

项目采用模块化架构，代码结构清晰，职责分离，易于维护和扩展。每个模块都有明确的职责和接口，可以独立开发和测试。

### 🏗️ 架构设计原则

**职责分离 (Separation of Concerns)**：
- ✅ **算法模块**：只负责计算，不操作UI
- ✅ **绘制模块**：专注于图形渲染，不包含业务逻辑
- ✅ **控制模块**：协调各模块交互，管理应用状态
- ✅ **数据格式**：统一的结构化数据传递

**例子：边缘检测流程**
```
EdgeDetectionAlgorithm (计算) 
    ↓ 返回边缘点数组
GraffitiApp (协调)
    ↓ 调用绘制方法
ImageProcessor (渲染)
```

### 🔧 模块扩展指南

- **DrawingEngine**: 添加新的画笔样式、几何图形绘制工具
- **ImageProcessor**: 实现图像滤镜、特效处理功能、自定义网格算法、厚度轮廓算法
- **EdgeDetectionAlgorithm**: 集成高级边缘检测算法（Canny、Sobel等）
- **GraffitiApp**: 添加新的UI功能、键盘快捷键、撤销/重做
- **Utils**: 扩展数学工具、性能监控、调试辅助功能

### 💡 建议的功能扩展

- 不同的画笔样式和纹理
- 几何图形绘制工具
- 高级边缘检测算法（Canny、Sobel等）
- 图像滤镜和特效
- 图层功能和混合模式
- 撤销/重做功能
- 矢量图形支持
- 实时协作功能
- 可配置的网格等分数量（支持4等分、8等分、12等分等）
- 网格动画效果和过渡动画
- 网格数据导出功能（JSON、SVG格式）
- 自定义厚度函数编辑器（可视化函数曲线编辑）
- 厚度轮廓动画效果（厚度变化动画）
- 3D厚度轮廓效果（立体感渲染）
- 厚度轮廓纹理填充（支持图案和渐变）

### 📊 API数据格式

**边缘检测结果格式**：
```javascript
// 结构化点对象数组
const edgePoints = [
    {x: 100, y: 50},
    {x: 105, y: 52},
    {x: 110, y: 48}
];
```

**基本配置API**：
```javascript
// 配置边缘绘制参数
app.setEdgeDrawConfig({
    color: '#ff0000',
    radius: 2,
    enabled: true,
    drawLines: true,
    tolerance: 10,
    gridColor: '#00ff00',
    drawSubdivisions: true
});

// 配置厚度轮廓参数
app.setThicknessConfig({
    enabled: true,
    thicknessFunction: 'fish',
    maxThickness: 40,
    minThickness: 3,
    fillColor: '#ff6b35'
});

// 配置预处理参数
app.setEdgeProcessConfig({
    enableSort: true,
    enableCompress: true,
    tolerance: 2.0
});
```
- ✅ **职责分离，算法与绘制解耦**
- ✅ **智能路径排序**，将散乱点组织成连续路径
- ✅ **道格拉斯-普克压缩**，大幅减少冗余点
- ✅ **可配置的预处理流程**，灵活控制处理策略
- ✅ **连线绘制功能**，形成清晰的轮廓线条
- ✅ **多种绘制模式**，适应不同的视觉需求
- ✅ **6等分网格生成**，自动创建精细网格结构
- ✅ **智能点匹配**，基于容差的连接点匹配算法
- ✅ **线性插值算法**，自动补充缺失的连接点
- ✅ **厚度轮廓算法**，基于鱼形函数的自然厚度分布
- ✅ **多种厚度函数**，支持鱼形、椭圆形、纺锤形、叶子形等
- ✅ **丰富可视化方式**，线条、圆形、渐变三种绘制模式

## 边缘检测算法优势

**5点扫描带 vs 单线扫描**：
- ✅ **良好容错性**：±2像素的容错范围，能够处理大部分位置偏差
- ✅ **稳定覆盖率**：有效检测常规线条和一般间隙情况  
- ✅ **基础稳定性**：抵抗基本的噪点和图片质量问题
- ✅ **广泛适应性**：对常见的手绘线条和图片边缘检测效果良好
- ✅ **轻量高效**：算法简洁，运行速度快，资源占用少
- ✅ **实用性强**：满足大部分日常涂鸦和图像处理需求
- ✅ **智能垂线**：自动生成6等分垂线，形成精细的垂线结构
- ✅ **可定制性**：支持自定义垂线颜色、线宽、容差等参数
- ✅ **厚度轮廓**：基于鱼形算法的自然厚度分布，实现艺术化效果
- ✅ **多样化函数**：鱼形、椭圆形、纺锤形、叶子形等多种厚度函数
- ✅ **灵活可视化**：线条、圆形、渐变三种可视化方式可选

### 🚀 算法进化历程

| 版本 | 检测方式 | 容错范围 | 适用场景 | 可靠性 |
|------|----------|----------|----------|--------|
| 1.0 | 单线扫描 | 0像素 | 理想线条 | ⭐⭐ |
| **2.0** | **5点扫描带** | **±2像素** | **日常使用** | **⭐⭐⭐** |
| **3.0** | **6等分垂线** | **智能匹配** | **统一颜色垂线** | **⭐⭐⭐⭐** |
| **4.0** | **厚度轮廓** | **鱼形函数** | **艺术化效果** | **⭐⭐⭐⭐⭐** |

### 🎯 5点扫描带结构示意
```
扫描方向 →
    ●    ← 点-2
    ●    ← 点-1
    ●    ← 中心（记录位置）
    ●    ← 点+1
    ●    ← 点+2
         ← 容错范围：±2像素
```

### 🕸️ 6等分垂线结构示意
```
垂线连接1  垂线连接2  垂线连接3
    ●----------●----------●     ← 0/6 (起始点)
    ●----------●----------●     ← 1/6
    ●----------●----------●     ← 2/6
    ●----------●----------●     ← 3/6 (中点)
    ●----------●----------●     ← 4/6
    ●----------●----------●     ← 5/6
    ●----------●----------●     ← 6/6 (结束点)
    ↑          ↑          ↑
  绿色主垂线  绿色等分线  红色端点
```

### 🕸️ 6等分垂线API

**核心功能**：
```javascript
// 手动生成和绘制6等分网格
const points = [{x: 100, y: 100}, {x: 200, y: 150}, {x: 300, y: 100}];
const splitResult = graffitiApp.imageProcessor.splitPointsAtRightmost(points);
const verticalLines = graffitiApp.imageProcessor.generateVerticalLines(
    splitResult.firstArray, 
    splitResult.secondArray, 
    10  // 容差
);

// 绘制完整垂线（垂直线+6等分）
graffitiApp.imageProcessor.drawVerticalLines(verticalLines, {
    gridColor: '#00ff00',          // 绿色垂直线
    gridLineWidth: 2,
    drawSubdivisions: true,        // 启用6等分
    subdivisionColor: '#00ff00',   // 等分线颜色（与主网格相同）
    subdivisionLineWidth: 1,
    drawGridPoints: true,          // 显示网格点
    gridPointRadius: 3,
    gridPointColor: '#ff0000'      // 红色网格点
});

// 只绘制6等分线，隐藏主垂线
graffitiApp.imageProcessor.drawVerticalLines(verticalLines, {
    gridColor: 'transparent',      // 隐藏主网格
    drawSubdivisions: true,        // 启用6等分
    subdivisionColor: '#ff6b35',   // 橙色等分线（自定义颜色）
    subdivisionLineWidth: 2
});

// 使用6等分垂线功能
graffitiApp.handleEdgeDetection();
```

**算法原理**：
1. **轮廓切分** - 找到最右侧点，将轮廓分成两条线
2. **垂线生成** - 根据X坐标和容差匹配点，形成垂线连接
3. **线性插值** - 距离较远的点进行插值，补充连接点
4. **6等分计算** - 每条垂线连接分成6等分，产生7个等分点
5. **水平连线** - 相邻垂线的对应等分点之间绘制水平连线（与垂线颜色一致）

**技术特点**：
- 🎯 **智能匹配** - 基于容差的点匹配算法
- 🔧 **线性插值** - 自动补充缺失的连接点
- 📐 **精确等分** - 数学计算确保等分点精度
- 🎨 **分层绘制** - 主垂线、等分线、端点分层渲染
- ⚡ **性能优化** - 批量绘制，减少Canvas操作次数
- 🌈 **颜色统一** - 横向和纵向线条使用相同颜色，保持视觉一致性

### 🐠 厚度轮廓API

**核心功能**：
```javascript
// 启用厚度轮廓功能
graffitiApp.setThicknessConfig({
    enabled: true,                    // 启用厚度功能
    thicknessFunction: 'fish',        // 厚度函数类型
    maxThickness: 40,                 // 最大厚度
    minThickness: 3,                  // 最小厚度
    fillColor: '#ff6b35',             // 填充颜色
    strokeColor: '#dc3545',           // 描边颜色
    strokeWidth: 1,                   // 描边宽度
    drawOutline: true,                // 是否绘制轮廓
    drawFill: true,                   // 是否填充
    thicknessVisualization: 'gradient' // 可视化方式
});

// 边缘检测会自动应用厚度轮廓
graffitiApp.handleEdgeDetection();

// 手动处理厚度轮廓
const points = [{x: 100, y: 100}, {x: 200, y: 120}, {x: 300, y: 100}];
const thickContour = graffitiApp.imageProcessor.processAndDrawThickContour(
    points,
    {
        thicknessFunction: 'ellipse',    // 椭圆形厚度
        maxThickness: 30,
        minThickness: 2
    },
    {
        fillColor: '#28a745',            // 绿色填充
        thicknessVisualization: 'circle', // 圆形可视化
        drawOutline: true,
        drawFill: true
    }
);

// 使用厚度轮廓功能
graffitiApp.handleEdgeDetection();
```

**厚度函数说明**：
- **fish** - 鱼形：头部尖锐、身体厚实、尾部细小
- **ellipse** - 椭圆形：中间厚、两端细的对称形状
- **spindle** - 纺锤形：平滑过渡的梭形效果
- **leaf** - 叶子形：一端尖锐、一端圆润的不对称形状

**可视化方式**：
- **line** - 线条模式：用垂直线条表示厚度
- **circle** - 圆形模式：用圆形表示厚度
- **gradient** - 渐变模式：填充形状表示厚度

**算法特点**：
- 🐠 **鱼形算法** - 模拟自然生物的形状特征
- 📐 **数学精确** - 基于数学函数计算厚度分布
- 🎨 **多种可视化** - 支持线条、圆形、渐变三种绘制方式
- 🔧 **高度可配置** - 支持自定义所有参数
- ⚡ **高性能** - 优化的算法确保流畅的绘制体验

---

**Made with ❤️ 享受创作的乐趣！** 